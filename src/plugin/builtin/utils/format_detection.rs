use std::path::Path;
use crate::plugin::builtin::export::config::ExportFormat;

/// Format detection result
#[derive(Debug, Clone, PartialEq)]
pub enum FormatDetectionResult {
    /// Format was successfully detected from extension
    Detected(ExportFormat),
    /// Extension is unknown/unsupported
    UnknownExtension(String),
    /// No extension found in the path
    NoExtension,
    /// Invalid path (empty, etc.)
    InvalidPath,
}

/// Format detection configuration and utilities
pub struct FormatDetector {
    /// Whether to enable logging of detection decisions
    enable_logging: bool,
}

impl FormatDetector {
    /// Create a new format detector
    pub fn new() -> Self {
        Self {
            enable_logging: true,
        }
    }

    /// Create a new format detector with logging configuration
    pub fn with_logging(enable_logging: bool) -> Self {
        Self {
            enable_logging,
        }
    }

    /// Detect format from file extension
    pub fn detect_format_from_path<P: AsRef<Path>>(&self, path: P) -> FormatDetectionResult {
        let path = path.as_ref();
        
        // Validate path
        if path.as_os_str().is_empty() {
            if self.enable_logging {
                log::debug!("Format detection: Invalid empty path");
            }
            return FormatDetectionResult::InvalidPath;
        }

        // Extract extension
        let extension = match path.extension().and_then(|ext| ext.to_str()) {
            Some(ext) => ext.to_lowercase(),
            None => {
                if self.enable_logging {
                    log::debug!("Format detection: No extension found in path: {}", path.display());
                }
                return FormatDetectionResult::NoExtension;
            }
        };

        // Map extension to format
        let detected_format = self.extension_to_format(&extension);
        
        match detected_format {
            Some(format) => {
                if self.enable_logging {
                    log::debug!("Format detection: Detected {:?} from extension '.{}'", format, extension);
                }
                FormatDetectionResult::Detected(format)
            }
            None => {
                if self.enable_logging {
                    log::debug!("Format detection: Unknown extension '.{}'", extension);
                }
                FormatDetectionResult::UnknownExtension(extension)
            }
        }
    }

    /// Map file extension to export format
    fn extension_to_format(&self, extension: &str) -> Option<ExportFormat> {
        match extension {
            // JSON formats
            "json" => Some(ExportFormat::Json),
            
            // CSV formats
            "csv" => Some(ExportFormat::Csv),
            "tsv" => Some(ExportFormat::Csv), // Tab-separated values treated as CSV
            
            // XML formats
            "xml" => Some(ExportFormat::Xml),
            
            // YAML formats
            "yaml" | "yml" => Some(ExportFormat::Yaml),
            
            // HTML formats
            "html" | "htm" => Some(ExportFormat::Html),
            
            // Markdown formats
            "md" | "markdown" => Some(ExportFormat::Markdown),
            
            // Plain text defaults to JSON (most structured)
            "txt" => Some(ExportFormat::Json),
            
            // Unknown extension
            _ => None,
        }
    }

    /// Get all supported extensions
    pub fn supported_extensions(&self) -> Vec<&'static str> {
        vec![
            "json", "csv", "tsv", "xml", "yaml", "yml", 
            "html", "htm", "md", "markdown", "txt"
        ]
    }

    /// Get supported extensions as a formatted string for error messages
    pub fn supported_extensions_string(&self) -> String {
        self.supported_extensions().join(", ")
    }

    /// Get extensions that map to a specific format
    pub fn get_extensions_for_format(&self, format: &ExportFormat) -> Vec<&'static str> {
        match format {
            ExportFormat::Json => vec!["json", "txt"],
            ExportFormat::Csv => vec!["csv", "tsv"],
            ExportFormat::Xml => vec!["xml"],
            ExportFormat::Yaml => vec!["yaml", "yml"],
            ExportFormat::Html => vec!["html", "htm"],
            ExportFormat::Markdown => vec!["md", "markdown"],
        }
    }

    /// Validate that a format can be generated by templates
    pub fn is_template_compatible(&self, format: &ExportFormat) -> bool {
        // All current formats are template-compatible
        match format {
            ExportFormat::Json => true,
            ExportFormat::Csv => true,
            ExportFormat::Xml => true,
            ExportFormat::Yaml => true,
            ExportFormat::Html => true,
            ExportFormat::Markdown => true,
        }
    }

    /// Generate format suggestion error message
    pub fn format_suggestion_error(&self, unknown_extension: &str) -> String {
        format!(
            "Unknown format for extension '.{}'. Supported formats: {}",
            unknown_extension,
            self.supported_extensions_string()
        )
    }

    /// Generate no extension error message
    pub fn no_extension_error(&self) -> String {
        "Cannot detect format: no file extension provided. Please specify --format or use a filename with a supported extension".to_string()
    }
}

impl Default for FormatDetector {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_detect_format_from_path() {
        let detector = FormatDetector::new();

        // Test JSON detection
        assert_eq!(
            detector.detect_format_from_path("report.json"),
            FormatDetectionResult::Detected(ExportFormat::Json)
        );

        // Test CSV detection
        assert_eq!(
            detector.detect_format_from_path("data.csv"),
            FormatDetectionResult::Detected(ExportFormat::Csv)
        );

        // Test TSV detection (should map to CSV)
        assert_eq!(
            detector.detect_format_from_path("data.tsv"),
            FormatDetectionResult::Detected(ExportFormat::Csv)
        );

        // Test XML detection
        assert_eq!(
            detector.detect_format_from_path("output.xml"),
            FormatDetectionResult::Detected(ExportFormat::Xml)
        );

        // Test YAML detection
        assert_eq!(
            detector.detect_format_from_path("config.yaml"),
            FormatDetectionResult::Detected(ExportFormat::Yaml)
        );
        assert_eq!(
            detector.detect_format_from_path("config.yml"),
            FormatDetectionResult::Detected(ExportFormat::Yaml)
        );

        // Test HTML detection
        assert_eq!(
            detector.detect_format_from_path("report.html"),
            FormatDetectionResult::Detected(ExportFormat::Html)
        );
        assert_eq!(
            detector.detect_format_from_path("report.htm"),
            FormatDetectionResult::Detected(ExportFormat::Html)
        );

        // Test Markdown detection
        assert_eq!(
            detector.detect_format_from_path("readme.md"),
            FormatDetectionResult::Detected(ExportFormat::Markdown)
        );
        assert_eq!(
            detector.detect_format_from_path("readme.markdown"),
            FormatDetectionResult::Detected(ExportFormat::Markdown)
        );

        // Test TXT detection (should default to JSON)
        assert_eq!(
            detector.detect_format_from_path("output.txt"),
            FormatDetectionResult::Detected(ExportFormat::Json)
        );
    }

    #[test]
    fn test_case_insensitive_detection() {
        let detector = FormatDetector::new();

        // Test case insensitive matching
        assert_eq!(
            detector.detect_format_from_path("REPORT.JSON"),
            FormatDetectionResult::Detected(ExportFormat::Json)
        );
        assert_eq!(
            detector.detect_format_from_path("Data.CSV"),
            FormatDetectionResult::Detected(ExportFormat::Csv)
        );
        assert_eq!(
            detector.detect_format_from_path("Config.YAML"),
            FormatDetectionResult::Detected(ExportFormat::Yaml)
        );
    }

    #[test]
    fn test_multiple_dots_uses_last_extension() {
        let detector = FormatDetector::new();

        // Test that multiple dots use the last extension
        assert_eq!(
            detector.detect_format_from_path("report.backup.json"),
            FormatDetectionResult::Detected(ExportFormat::Json)
        );
        assert_eq!(
            detector.detect_format_from_path("data.2024.csv"),
            FormatDetectionResult::Detected(ExportFormat::Csv)
        );
    }

    #[test]
    fn test_unknown_extension() {
        let detector = FormatDetector::new();

        // Test unknown extensions
        assert_eq!(
            detector.detect_format_from_path("output.xyz"),
            FormatDetectionResult::UnknownExtension("xyz".to_string())
        );
        assert_eq!(
            detector.detect_format_from_path("data.unknown"),
            FormatDetectionResult::UnknownExtension("unknown".to_string())
        );
    }

    #[test]
    fn test_no_extension() {
        let detector = FormatDetector::new();

        // Test files without extensions
        assert_eq!(
            detector.detect_format_from_path("output"),
            FormatDetectionResult::NoExtension
        );
        assert_eq!(
            detector.detect_format_from_path("data"),
            FormatDetectionResult::NoExtension
        );
    }

    #[test]
    fn test_invalid_path() {
        let detector = FormatDetector::new();

        // Test empty path
        assert_eq!(
            detector.detect_format_from_path(""),
            FormatDetectionResult::InvalidPath
        );
    }

    #[test]
    fn test_supported_extensions() {
        let detector = FormatDetector::new();
        let extensions = detector.supported_extensions();
        
        // Verify all expected extensions are present
        assert!(extensions.contains(&"json"));
        assert!(extensions.contains(&"csv"));
        assert!(extensions.contains(&"tsv"));
        assert!(extensions.contains(&"xml"));
        assert!(extensions.contains(&"yaml"));
        assert!(extensions.contains(&"yml"));
        assert!(extensions.contains(&"html"));
        assert!(extensions.contains(&"htm"));
        assert!(extensions.contains(&"md"));
        assert!(extensions.contains(&"markdown"));
        assert!(extensions.contains(&"txt"));
    }

    #[test]
    fn test_template_compatibility() {
        let detector = FormatDetector::new();

        // All formats should be template compatible
        assert!(detector.is_template_compatible(&ExportFormat::Json));
        assert!(detector.is_template_compatible(&ExportFormat::Csv));
        assert!(detector.is_template_compatible(&ExportFormat::Xml));
        assert!(detector.is_template_compatible(&ExportFormat::Yaml));
        assert!(detector.is_template_compatible(&ExportFormat::Html));
        assert!(detector.is_template_compatible(&ExportFormat::Markdown));
    }

    #[test]
    fn test_error_messages() {
        let detector = FormatDetector::new();

        // Test format suggestion error
        let error = detector.format_suggestion_error("xyz");
        assert!(error.contains("Unknown format for extension '.xyz'"));
        assert!(error.contains("json, csv"));

        // Test no extension error
        let error = detector.no_extension_error();
        assert!(error.contains("Cannot detect format"));
        assert!(error.contains("no file extension provided"));
    }
}
