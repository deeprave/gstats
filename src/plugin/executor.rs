//! Plugin Executor for Scanner Integration
//!
//! Integrates the plugin system with the async scanner engine to process messages
//! in real-time as they flow through the scanning pipeline.

use std::sync::Arc;
use async_trait::async_trait;
use tokio::sync::RwLock;
use futures::{Stream, StreamExt};
use crate::scanner::messages::ScanMessage;
use crate::scanner::modes::ScanMode;
use crate::scanner::async_traits::ScanMessageStream;
use crate::scanner::async_engine::error::{ScanError, ScanResult};
use crate::plugin::{
    ScannerPlugin, PluginResult, SharedPluginRegistry, PluginRegistry
};
use std::pin::Pin;
use std::task::{Context, Poll};
use pin_project::pin_project;

/// Plugin executor that processes messages through registered plugins
pub struct PluginExecutor {
    registry: Arc<RwLock<PluginRegistry>>,
    scan_modes: ScanMode,
    /// Track execution metrics
    metrics: Arc<RwLock<ExecutionMetrics>>,
}

#[derive(Debug, Default, Clone)]
struct ExecutionMetrics {
    messages_processed: u64,
    plugin_executions: u64,
    errors: u64,
    total_processing_time_ms: u64,
}

impl PluginExecutor {
    /// Create a new plugin executor
    pub fn new(registry: SharedPluginRegistry, scan_modes: ScanMode) -> Self {
        Self {
            registry: registry.inner().clone(),
            scan_modes,
            metrics: Arc::new(RwLock::new(ExecutionMetrics::default())),
        }
    }

    /// Process a single message through all applicable plugins
    pub async fn process_message(&self, message: ScanMessage) -> Vec<ScanMessage> {
        let start_time = std::time::Instant::now();
        let mut results = vec![message.clone()];
        
        // Get scanner plugins that support current scan mode
        let plugin_names = match self.get_applicable_plugins().await {
            Ok(plugins) => plugins,
            Err(e) => {
                log::error!("Failed to get plugins: {}", e);
                return results;
            }
        };

        // Process message through each plugin
        for plugin_name in plugin_names {
            log::debug!("Processing message through plugin: {}", plugin_name);
            
            // For now, we'll just log that we would process through the plugin
            // In a full implementation, we'd need to safely downcast and call process_scan_data
            log::trace!("Plugin {} would process message", plugin_name);
            
            // Update metrics
            let mut metrics = self.metrics.write().await;
            metrics.plugin_executions += 1;
        }

        // Update processing metrics
        let processing_time = start_time.elapsed();
        let mut metrics = self.metrics.write().await;
        metrics.messages_processed += 1;
        metrics.total_processing_time_ms += processing_time.as_millis() as u64;

        results
    }

    /// Get plugins that support the current scan modes
    async fn get_applicable_plugins(&self) -> PluginResult<Vec<String>> {
        let registry = self.registry.read().await;
        let scanner_plugin_names = registry.get_plugins_by_type(crate::plugin::traits::PluginType::Scanner);
        
        let mut applicable = Vec::new();
        for name in scanner_plugin_names {
            if let Some(plugin) = registry.get_plugin(&name) {
                // Try to downcast to ScannerPlugin to check modes
                // For now, just add all scanner plugins
                applicable.push(name);
            }
        }
        
        Ok(applicable)
    }

    /// Create a plugin-processing stream from an input stream
    pub fn create_plugin_stream<S>(&self, input: S) -> PluginStream<S>
    where
        S: Stream<Item = ScanResult<ScanMessage>> + Send + 'static,
    {
        PluginStream::new(input, Arc::new(self.clone()))
    }

    /// Get execution metrics
    pub async fn get_metrics(&self) -> ExecutionMetrics {
        self.metrics.read().await.clone()
    }
}

impl Clone for PluginExecutor {
    fn clone(&self) -> Self {
        Self {
            registry: Arc::clone(&self.registry),
            scan_modes: self.scan_modes,
            metrics: Arc::clone(&self.metrics),
        }
    }
}

/// Stream wrapper that processes messages through plugins
#[pin_project]
pub struct PluginStream<S> {
    #[pin]
    inner: S,
    executor: Arc<PluginExecutor>,
    /// Buffer for messages generated by plugins
    buffer: Vec<ScanMessage>,
}

impl<S> PluginStream<S>
where
    S: Stream<Item = ScanResult<ScanMessage>>,
{
    pub fn new(stream: S, executor: Arc<PluginExecutor>) -> Self {
        Self {
            inner: stream,
            executor,
            buffer: Vec::new(),
        }
    }
}

impl<S> Stream for PluginStream<S>
where
    S: Stream<Item = ScanResult<ScanMessage>> + Send,
{
    type Item = ScanResult<ScanMessage>;

    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        let mut this = self.project();

        // First, check if we have buffered messages
        if let Some(message) = this.buffer.pop() {
            return Poll::Ready(Some(Ok(message)));
        }

        // Poll the inner stream
        match this.inner.as_mut().poll_next(cx) {
            Poll::Ready(Some(Ok(message))) => {
                // Process message through plugins
                let executor = Arc::clone(this.executor);
                let message_clone = message.clone();
                
                // We need to process the message, but we're in a sync context
                // For now, we'll just pass through the original message and
                // queue plugin processing as a separate task
                let runtime = tokio::runtime::Handle::current();
                runtime.spawn(async move {
                    let results = executor.process_message(message_clone).await;
                    // In a real implementation, we'd need a way to feed these
                    // back into the stream or a separate channel
                    log::trace!("Plugin processing generated {} messages", results.len());
                });

                Poll::Ready(Some(Ok(message)))
            }
            Poll::Ready(Some(Err(e))) => Poll::Ready(Some(Err(e))),
            Poll::Ready(None) => Poll::Ready(None),
            Poll::Pending => Poll::Pending,
        }
    }
}

/// Plugin-aware message processor for scanner integration
pub struct PluginMessageProcessor {
    executor: PluginExecutor,
    output_channel: tokio::sync::mpsc::Sender<ScanMessage>,
}

impl PluginMessageProcessor {
    /// Create a new plugin message processor
    pub fn new(
        registry: SharedPluginRegistry, 
        scan_modes: ScanMode,
        output_channel: tokio::sync::mpsc::Sender<ScanMessage>,
    ) -> Self {
        Self {
            executor: PluginExecutor::new(registry, scan_modes),
            output_channel,
        }
    }

    /// Process a stream of messages through plugins
    pub async fn process_stream<S>(&self, mut stream: S) -> ScanResult<()>
    where
        S: Stream<Item = ScanResult<ScanMessage>> + Send + Unpin,
    {
        while let Some(result) = stream.next().await {
            match result {
                Ok(message) => {
                    // Process through plugins
                    let results = self.executor.process_message(message).await;
                    
                    // Send all results to output channel
                    for msg in results {
                        if let Err(e) = self.output_channel.send(msg).await {
                            log::error!("Failed to send message to output: {}", e);
                            return Err(ScanError::stream(format!("Channel send failed: {}", e)));
                        }
                    }
                }
                Err(e) => {
                    log::error!("Stream error: {}", e);
                    return Err(e);
                }
            }
        }
        
        Ok(())
    }

    /// Get execution metrics
    pub async fn get_metrics(&self) -> ExecutionMetrics {
        self.executor.get_metrics().await
    }
}

/// Extension trait for integrating plugins with scanner streams
#[async_trait]
pub trait PluginStreamExt: Stream<Item = ScanResult<ScanMessage>> + Send + Sized + 'static {
    /// Process messages through plugins
    fn with_plugins(self, executor: Arc<PluginExecutor>) -> PluginStream<Self> {
        PluginStream::new(self, executor)
    }
}

// Implement the extension trait for all suitable streams
impl<S> PluginStreamExt for S 
where 
    S: Stream<Item = ScanResult<ScanMessage>> + Send + 'static 
{}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::plugin::registry::PluginRegistry;
    use crate::plugin::tests::mock_plugins::{MockScannerPlugin, create_test_context};
    use crate::scanner::messages::{MessageHeader, MessageData};
    use futures::stream;

    async fn create_test_registry() -> SharedPluginRegistry {
        let registry = SharedPluginRegistry::new();
        
        // Add a test plugin
        let plugin = Box::new(MockScannerPlugin::new(
            "test-scanner", 
            ScanMode::FILES,
            false
        ));
        
        registry.inner().write().await.register_plugin(plugin).await.unwrap();
        
        registry
    }

    fn create_test_message() -> ScanMessage {
        ScanMessage::new(
            MessageHeader::new(ScanMode::FILES, 12345),
            MessageData::FileInfo {
                path: "test.rs".to_string(),
                size: 1024,
                lines: 50,
            }
        )
    }

    #[tokio::test]
    async fn test_plugin_executor_creation() {
        let registry = create_test_registry().await;
        let executor = PluginExecutor::new(registry, ScanMode::FILES);
        
        let metrics = executor.get_metrics().await;
        assert_eq!(metrics.messages_processed, 0);
        assert_eq!(metrics.plugin_executions, 0);
    }

    #[tokio::test]
    async fn test_message_processing() {
        let registry = create_test_registry().await;
        let executor = PluginExecutor::new(registry.clone(), ScanMode::FILES);
        
        // Initialize the plugin
        let _context = create_test_context();
        {
            let mut reg = registry.inner().write().await;
            if let Some(_plugin) = reg.get_plugin_mut("test-scanner") {
                // Plugin already exists, no need to create a new one
                // Just initialize it
                // plugin.initialize(&context).await.unwrap();
            }
        }
        
        let message = create_test_message();
        let results = executor.process_message(message).await;
        
        // Should have original message plus processed message
        assert!(!results.is_empty());
        
        let metrics = executor.get_metrics().await;
        assert_eq!(metrics.messages_processed, 1);
    }

    #[tokio::test]
    async fn test_plugin_stream() {
        let registry = create_test_registry().await;
        let executor = Arc::new(PluginExecutor::new(registry, ScanMode::FILES));
        
        // Create a test stream
        let messages = vec![
            Ok(create_test_message()),
            Ok(create_test_message()),
        ];
        let stream = stream::iter(messages);
        
        // Wrap with plugin processing
        let mut plugin_stream = stream.with_plugins(executor);
        
        // Collect results
        let mut count = 0;
        while let Some(result) = plugin_stream.next().await {
            assert!(result.is_ok());
            count += 1;
        }
        
        assert_eq!(count, 2);
    }

    #[tokio::test]
    async fn test_plugin_message_processor() {
        let registry = create_test_registry().await;
        let (tx, mut rx) = tokio::sync::mpsc::channel(100);
        
        let processor = PluginMessageProcessor::new(
            registry,
            ScanMode::FILES,
            tx
        );
        
        // Create test stream
        let messages = vec![
            Ok(create_test_message()),
            Ok(create_test_message()),
        ];
        let stream = stream::iter(messages);
        
        // Process stream
        processor.process_stream(stream).await.unwrap();
        
        // Check output
        let mut count = 0;
        while let Ok(msg) = rx.try_recv() {
            count += 1;
        }
        
        assert!(count >= 2); // At least the original messages
    }
}